// This is based on tutorial 09 design 01 (PLL test) Digi-Key tutorial on FPGAs #9 https://www.youtube.com/watch?v=gmaSjyUij9E
//
// Mods based on https://github.com/YosysHQ/yosys/issues/107
//   which leads to https://github.com/carlosgs/iceDAQ/blob/master/pll_example/pll_example.v
//
// Interesting info from the YosysHQ answer:
//   The RESETB signal is inverted (thus the B). So it must be set to 1 in order for the PLL to run. (I didn't notice this)
//   The valid range for DIVQ is 1..6. This is correctly documented in the ICE Technology Library Document,
//       but unfortunately incorrectly documented as 0..7 in the iCE40 sysCLOCK PLL Design and Usage Guide.
//   The valid PLL output range is 16 - 275 MHz.
//   Also, I wanted to check with you whether it is normal that the clock input is not assigned to a Global Buffer by default:
//       You are not using it as a clock anywhere in the design. Drive the clock input of FFs with it and arachne-pnr will
//       route the signal through a clock buffer. Alternatively you can manually instantiate a clock buffer (SB_GB or SB_GB_IO)
//       for a signal. When using PLLs you need to use the PLLOUTGLOBAL output if you want to use the direct path from the PLL
//       to the global clock distribution network.
//
// The output PLL clock is PLLOUTCORE originally in Digi-Key tutorial on FPGAs #9
// In the carlosgs example above, it was originally also PLLOUTCORE
// It was changed to PLLOUTGLOBAL
//
// Here from the iCE40 sysCLOCK PLL Design and Usage Guide: Global Buffers are automatically inferred when GBIN ports are used as a clock input
// Here from the iCE40 LP/HX Family Data Sheet:
//     PLLOUTGLOBAL - Output from the Phase-Locked Loop (PLL). Drives a global clock network on the FPGA. The port has optimal connections to global clock buffers GBUF4 and GBUF5
//     PLLOUTCORE   - Output clock generated by the PLL, drives regular FPGA routing. The frequency generated on this output is the same as the frequency of the clock signal generated on the PLLOUTLGOBAL port.
//
/*
   $ apio raw "icepll -i 12 -o 96"

   F_PLLIN:    12.000 MHz (given)
   F_PLLOUT:   96.000 MHz (requested)
   F_PLLOUT:   96.000 MHz (achieved)

   FEEDBACK: SIMPLE
   F_PFD:   12.000 MHz
   F_VCO:  768.000 MHz

   DIVR:  0 (4'b0000)
   DIVF: 63 (7'b0111111)
   DIVQ:  3 (3'b011)

   FILTER_RANGE: 1 (3'b001)   
*/                         
module rgb_pll (          
                           
    // Inputs              
    input   ref_clk,       
                           
    // outputs             
    output  clk_96,           
    output  locked         
);                         
                           
    // Instantiate PLL (   12 MHz in, 96 MHz out) for iCE_STICK
    SB_PLL40_CORE #(       
        .FEEDBACK_PATH("   SIMPLE"),// don't use fine delay adjustment
        .PLLOUT_SELECT("   GENCLK"),// no phase shift on output
        .DIVR(4'B0000),             // reference clock divider (from icepll tool)
        .DIVF(7'b0111111),          // feedback clock divider (ditto)
        .DIVQ(3'B011),              // VCO clock divider (ditto)
        .FILTER_RANGE(3'B001)       // filter range (ditto)
    ) pll (                
        .REFERENCECLK(ref_clk),     // input clock
        .PLLOUTGLOBAL(clk_96),      // output clock - PLLOUTCORE originally in Digi-Key tutorial on FPGAs #9
        .LOCK(locked),              // locked signal
        .RESETB(1'b1),              // active low reset; set to run always
        .BYPASS(1'b0)               // no bypass, use PLL signal as output
    );                     
                           
endmodule                  